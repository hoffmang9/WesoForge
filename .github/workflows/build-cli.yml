name: Build CLI and test -h

on:
  push:
    branches:
    - main
  release:
    types: [published]
  pull_request:
    branches:
    - '**'

jobs:
  build-and-test:
    name: ${{ matrix.os }} (${{ matrix.arch }})
    runs-on: ${{ matrix.runner }}
    env:
      # Linux: run AppImages without FUSE (extract and run) so downloaded linuxdeploy works in CI
      APPIMAGE_EXTRACT_AND_RUN: ${{ matrix.os == 'Linux' && '1' || '' }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: Linux
            runner: ubuntu-latest
            arch: x64
          - os: macOS
            runner: macos-latest
            arch: ARM64
          - os: macOS
            runner: macos-15-intel
            arch: x64
          - os: Windows
            runner: windows-latest
            arch: x64

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache Rust (target + registry)
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "rust"

      - name: Setup Node.js (Linux / macOS / Windows, for GUI)
        if: matrix.os == 'Linux' || matrix.os == 'macOS' || matrix.os == 'Windows'
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'

      - name: Prepare Linux
        if: matrix.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y git curl build-essential clang libgmp-dev libboost-all-dev gawk pkg-config
          sudo apt-get install -y pkg-config libgtk-3-dev libsoup-3.0-dev libwebkit2gtk-4.1-dev

      - name: Extract linuxdeploy for CI (no FUSE)
        if: matrix.os == 'Linux'
        run: |
          LINUXDEPLOY_DIR="$RUNNER_TEMP/linuxdeploy"
          mkdir -p "$LINUXDEPLOY_DIR" && cd "$LINUXDEPLOY_DIR"
          curl -sL -o linuxdeploy.AppImage "https://github.com/tauri-apps/binary-releases/releases/download/linuxdeploy/linuxdeploy-x86_64.AppImage"
          chmod +x linuxdeploy.AppImage
          ./linuxdeploy.AppImage --appimage-extract
          mv squashfs-root bin
          curl -sL -o plugin.AppImage "https://github.com/linuxdeploy/linuxdeploy-plugin-appimage/releases/download/continuous/linuxdeploy-plugin-appimage-x86_64.AppImage"
          chmod +x plugin.AppImage
          ./plugin.AppImage --appimage-extract
          if [ -f squashfs-root/usr/bin/linuxdeploy-plugin-appimage ]; then
            cp squashfs-root/usr/bin/linuxdeploy-plugin-appimage bin/
          elif [ -f squashfs-root/AppRun ]; then
            cp squashfs-root/AppRun bin/linuxdeploy-plugin-appimage
          fi
          chmod +x bin/linuxdeploy-plugin-appimage 2>/dev/null || true
          echo "LINUXDEPLOY=$LINUXDEPLOY_DIR/bin/AppRun" >> "$GITHUB_ENV"
          echo "$LINUXDEPLOY_DIR/bin" >> "$GITHUB_PATH"

      - name: Prepare macOS
        if: matrix.os == 'macOS'
        run: |
          brew install pkg-config gmp

      - name: Prepare macOS Intel (Boost)
        if: matrix.runner == 'macos-15-intel'
        run: brew install boost

      - name: Patch chiavdf for GMP 6.3 (macOS Intel)
        if: matrix.runner == 'macos-15-intel'
        run: git -C chiavdf apply "$GITHUB_WORKSPACE/patches/chiavdf-gmp63-mpz-macro.patch"

      - name: Prepare Windows (MPIR and LLVM)
        if: matrix.os == 'Windows'
        run: |
          git clone https://github.com/Chia-Network/mpir_gc_x64.git chiavdf/mpir_gc_x64
          winget install LLVM.LLVM --accept-package-agreements --accept-source-agreements --silent

      - name: Set Windows PATH for LLVM
        if: matrix.os == 'Windows'
        run: |
          echo "$env:ProgramFiles\LLVM\bin" | Out-File -Append -FilePath $env:GITHUB_PATH
          echo "PATH=$env:ProgramFiles\LLVM\bin;$env:PATH" >> $env:GITHUB_ENV

      - name: Install pnpm and Tauri CLI, then build Rust (CLI + GUI once)
        shell: bash
        env:
          CARGO_TARGET_DIR: ${{ github.workspace }}/target
        run: |
          corepack enable
          corepack prepare pnpm@latest --activate
          cargo install tauri-cli
          pnpm -C ui install
          # On Linux, force GUI rebuild so release binary has symbols (strip = false) for Tauri patch
          if [ "$(uname -s)" = "Linux" ]; then
            cargo clean -p bbr-client-gui
          fi
          cargo build --release -p bbr-client -p bbr-client-gui --features prod-backend
          case "$(uname -s)" in
            Linux)
              export LINUXDEPLOY="${RUNNER_TEMP:-/tmp}/linuxdeploy/bin/AppRun"
              export PATH="${RUNNER_TEMP:-/tmp}/linuxdeploy/bin:$PATH"
              (cd crates/client-gui && cargo tauri build --features prod-backend --bundles appimage)
              ;;
            Darwin) (cd crates/client-gui && cargo tauri build --features prod-backend --bundles dmg) ;;
          esac

      - name: Package CLI (Linux / macOS)
        if: matrix.os != 'Windows'
        env:
          BBR_SKIP_CARGO_BUILD: 1
        run: ./build-cli.sh

      - name: Package CLI (Windows)
        if: matrix.os == 'Windows'
        shell: pwsh
        env:
          BBR_SKIP_CARGO_BUILD: 1
        run: ./build-cli.ps1

      - name: Test -h output (Linux / macOS)
        if: matrix.os != 'Windows'
        run: |
          BIN="target/release/wesoforge"
          [ -f "$BIN" ] || { echo "Binary not found: $BIN"; exit 1; }
          OUTPUT="$("$BIN" -h 2>&1)"
          echo "$OUTPUT"
          echo "---"
          echo "$OUTPUT" | grep -q "WesoForge" || { echo "Expected -h output to contain 'WesoForge'"; exit 1; }
          echo "$OUTPUT" | grep -q "Usage" || { echo "Expected -h output to contain 'Usage'"; exit 1; }
          echo "$OUTPUT" | grep -q "compact proof worker" || { echo "Expected -h output to contain 'compact proof worker'"; exit 1; }
          echo "Help output assertions passed."

      - name: Test -h output (Windows)
        if: matrix.os == 'Windows'
        shell: pwsh
        run: |
          # Run from dist/ where MPIR DLLs are; target\release\wesoforge.exe would fail to load without them
          $distExe = Get-ChildItem -Path dist -Filter "WesoForge-cli_*.exe" | Select-Object -First 1
          if (-not $distExe) { throw "Binary not found in dist/" }
          $bin = $distExe.FullName
          # Clap prints -h to stderr; capture both streams so we get the full help text
          $outFile = "help-stdout.txt"
          $errFile = "help-stderr.txt"
          $null = Start-Process -FilePath $bin -ArgumentList "-h" -NoNewWindow -Wait -PassThru -RedirectStandardOutput $outFile -RedirectStandardError $errFile -WorkingDirectory (Split-Path $bin)
          $output = (Get-Content $outFile -Raw) + (Get-Content $errFile -Raw)
          Write-Host $output
          Write-Host "---"
          if ($output -notmatch "WesoForge") { throw "Expected -h output to contain 'WesoForge'" }
          if ($output -notmatch "Usage") { throw "Expected -h output to contain 'Usage'" }
          if ($output -notmatch "compact proof worker") { throw "Expected -h output to contain 'compact proof worker'" }
          Write-Host "Help output assertions passed."

      - name: Package GUI (Linux)
        if: matrix.os == 'Linux'
        env:
          BBR_SKIP_CARGO_BUILD: 1
        run: ./build-gui.sh

      - name: Package GUI (macOS)
        if: matrix.os == 'macOS'
        env:
          BBR_SKIP_CARGO_BUILD: 1
        run: ./build-gui.sh

      - name: Package GUI (Windows)
        if: matrix.os == 'Windows'
        shell: pwsh
        env:
          BBR_SKIP_CARGO_BUILD: 1
        run: ./build-gui.ps1

      - name: Upload dist artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ matrix.os }}-${{ matrix.arch }}
          path: dist/
